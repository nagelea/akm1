name: Periodic Key Verification

on:
  schedule:
    # æ¯å¤©æ—©ä¸Š6ç‚¹éªŒè¯æœªéªŒè¯çš„å¯†é’¥
    - cron: '0 6 * * *'
  workflow_dispatch:
    inputs:
      force_reverify:
        description: 'Force re-verify all keys'
        required: false
        default: 'false'
        type: boolean

jobs:
  verify:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm install @supabase/supabase-js
      
    - name: Run Key Verification
      env:
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        FORCE_REVERIFY: ${{ github.event.inputs.force_reverify || 'false' }}
      run: |
        echo "ğŸ” Starting Key Verification Task..."
        echo "Force re-verify: $FORCE_REVERIFY"
        
        # åˆ›å»ºéªŒè¯è„šæœ¬
        cat > verify-task.js << 'EOF'
        const { createClient } = require('@supabase/supabase-js');

        const supabase = createClient(
          process.env.SUPABASE_URL,
          process.env.SUPABASE_SERVICE_KEY
        );

        async function verifyUnverifiedKeys() {
          try {
            console.log('ğŸ” Fetching unverified keys...');
            
            // è·å–æœªéªŒè¯çš„å¯†é’¥ï¼ˆstatus = 'unknown' æˆ– last_verified ä¸ºç©ºï¼‰
            const query = supabase
              .from('leaked_keys')
              .select('id, key_type, leaked_keys_sensitive(*)')
              .eq('status', 'unknown');
            
            if (process.env.FORCE_REVERIFY === 'true') {
              console.log('ğŸ”„ Force re-verification mode - checking all keys');
              // å¼ºåˆ¶é‡æ–°éªŒè¯æ¨¡å¼ï¼šè·å–æ‰€æœ‰å¯†é’¥
              const { data: keys, error } = await supabase
                .from('leaked_keys')
                .select('id, key_type, leaked_keys_sensitive(*)')
                .order('created_at', { ascending: false });
              
              if (error) throw error;
              await processKeys(keys);
            } else {
              // æ­£å¸¸æ¨¡å¼ï¼šåªéªŒè¯æœªéªŒè¯çš„å¯†é’¥
              const { data: keys, error } = await query;
              
              if (error) throw error;
              await processKeys(keys);
            }
            
          } catch (error) {
            console.error('âŒ Verification task failed:', error);
            process.exit(1);
          }
        }

        async function processKeys(keys) {
          if (!keys || keys.length === 0) {
            console.log('âœ… No keys to verify');
            return;
          }

          console.log(`ğŸ“Š Found ${keys.length} keys to verify`);
          let successCount = 0;
          let failureCount = 0;

          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ•æ„Ÿæ•°æ®
            if (!key.leaked_keys_sensitive || 
                key.leaked_keys_sensitive.length === 0 || 
                !key.leaked_keys_sensitive[0].full_key) {
              console.log(`âš ï¸  Skipping key ${key.id} - no sensitive data`);
              continue;
            }

            try {
              console.log(`ğŸ”‘ Verifying key ${i + 1}/${keys.length}: ID ${key.id} (${key.key_type})`);
              
              const sensitiveData = key.leaked_keys_sensitive[0];
              const verificationResult = await verifyKey(key.key_type, sensitiveData.full_key, key);
              
              // æ£€æŸ¥æ˜¯å¦ä¸ºä¸æ”¯æŒçš„å¯†é’¥ç±»å‹
              if (verificationResult === 'unsupported') {
                console.log(`âš ï¸  Key ${key.id} (${key.key_type}) - verification not supported, keeping as unknown`);
                continue; // è·³è¿‡æ›´æ–°ï¼Œä¿æŒ unknown çŠ¶æ€
              }
              
              // æ›´æ–°æ•°æ®åº“çŠ¶æ€
              const { error: updateError } = await supabase
                .from('leaked_keys')
                .update({
                  status: verificationResult ? 'valid' : 'invalid',
                  last_verified: new Date().toISOString()
                })
                .eq('id', key.id);

              if (updateError) {
                console.error(`âŒ Failed to update key ${key.id}:`, updateError);
                failureCount++;
              } else {
                console.log(`âœ… Key ${key.id} verified as ${verificationResult ? 'valid' : 'invalid'}`);
                successCount++;
              }

              // æ·»åŠ å»¶è¿Ÿé¿å…APIé€Ÿç‡é™åˆ¶
              if (i < keys.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2ç§’å»¶è¿Ÿ
              }

            } catch (error) {
              console.error(`âŒ Error verifying key ${key.id}:`, error);
              failureCount++;
            }
          }

          console.log(`ğŸ¯ Verification completed: ${successCount} success, ${failureCount} failures`);
        }

        async function verifyKey(keyType, fullKey, keyObject = null) {
          try {
            switch (keyType.toLowerCase()) {
              case 'openai':
              case 'openai_project':
              case 'openai_user':
              case 'openai_service':
              case 'deepseek':
                const openaiContext = keyObject?.leaked_keys_sensitive?.[0]?.raw_context;
                return await verifyOpenAI(fullKey, openaiContext);
              case 'openai_org':
                return await verifyOpenAI(fullKey); // org keys ä¸éœ€è¦base_url
              case 'anthropic':
                return await verifyAnthropic(fullKey);
              case 'google':
              case 'google_service':
              case 'palm':
              case 'gemini':
                return await verifyGoogle(fullKey);
              case 'huggingface':
                return await verifyHuggingFace(fullKey);
              case 'replicate':
                return await verifyReplicate(fullKey);
              case 'together':
                return await verifyTogether(fullKey);
              case 'openrouter':
                return await verifyOpenRouter(fullKey);
              case 'perplexity':
                return await verifyPerplexity(fullKey);
              case 'groq':
                return await verifyGroq(fullKey);
              case 'azure_openai':
                // Azure OpenAI ä½¿ç”¨ä¸Šä¸‹æ–‡æå–endpoint
                const context = keyObject?.leaked_keys_sensitive?.[0]?.raw_context;
                return await verifyAzureOpenAI(fullKey, context);
              case 'vertex_ai':
                return await verifyVertexAI(fullKey);
              case 'cohere':
                return await verifyCohere(fullKey);
              case 'mistral':
                return await verifyMistral(fullKey);
              default:
                console.log(`âš ï¸  Unsupported key type: ${keyType}`);
                return 'unsupported';
            }
          } catch (error) {
            console.error(`Verification error for ${keyType}:`, error);
            return false;
          }
        }

        // ä»ä»£ç ä¸Šä¸‹æ–‡æå–OpenAIå…¼å®¹æœåŠ¡çš„base_url
        function extractOpenAIBaseURL(context) {
          if (!context) return null;
          
          const baseUrlPatterns = [
            // base_url èµ‹å€¼æ¨¡å¼
            /base_url["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            /api_base["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            /openai_api_base["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            
            // ç¯å¢ƒå˜é‡æ¨¡å¼
            /OPENAI_BASE_URL["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            /OPENAI_API_BASE["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            
            // ç›´æ¥URLæ¨¡å¼
            /https:\/\/[\w.-]+\/v1[^\s"'\)\];,}]*/gi,
            /https:\/\/[\w.-]+\.(?:com|cn|net|org)\/[^\s"'\)\];,}]*v1[^\s"'\)\];,}]*/gi
          ];
          
          for (const pattern of baseUrlPatterns) {
            const matches = [...context.matchAll(pattern)];
            if (matches.length > 0) {
              for (const match of matches) {
                let url = match[1] || match[0];
                // æ¸…ç†å¼•å·å’Œç©ºæ ¼
                url = url.replace(/^["'`\s]|["'`\s]$/g, '');
                
                // éªŒè¯URLæ ¼å¼ä¸”ä¸æ˜¯å®˜æ–¹API
                if (url.startsWith('http') && !url.includes('api.openai.com')) {
                  return url.replace(/\/+$/, ''); // ç§»é™¤æœ«å°¾æ–œæ 
                }
              }
            }
          }
          
          return null;
        }

        // å¢å¼ºOpenAIéªŒè¯ï¼Œæ”¯æŒè‡ªå®šä¹‰base_url
        async function verifyOpenAI(key, context = null) {
          try {
            // 1. å°è¯•æå–è‡ªå®šä¹‰base_url
            const customBaseUrl = extractOpenAIBaseURL(context);
            
            if (customBaseUrl) {
              console.log(`OpenAI: Trying custom base_url ${customBaseUrl}`);
              try {
                const modelsUrl = customBaseUrl.endsWith('/v1') ? 
                  `${customBaseUrl}/models` : `${customBaseUrl}/v1/models`;
                
                const response = await fetch(modelsUrl, {
                  headers: { 'Authorization': `Bearer ${key}` }
                });
                
                if (response.ok) {
                  console.log('OpenAI: Custom endpoint verification successful');
                  return true;
                } else if (response.status === 401 || response.status === 403) {
                  console.log('OpenAI: Custom endpoint - invalid key (401/403)');
                  return false;
                }
                
                console.log(`OpenAI: Custom endpoint returned ${response.status}, trying official API`);
              } catch (error) {
                console.log(`OpenAI: Custom endpoint error (${error.message}), trying official API`);
              }
            }
            
            // 2. é™çº§åˆ°å®˜æ–¹APIéªŒè¯
            const response = await fetch('https://api.openai.com/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            
            if (response.ok) {
              console.log('OpenAI: Official API verification successful');
              return true;
            } else {
              console.log(`OpenAI: Official API returned ${response.status}`);
              return false;
            }
            
          } catch (error) {
            console.log('OpenAI: Verification error:', error.message);
            return false;
          }
        }

        async function verifyAnthropic(key) {
          try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              headers: { 
                'x-api-key': key,
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01'
              },
              body: JSON.stringify({
                model: 'claude-3-haiku-20240307',
                max_tokens: 1,
                messages: [{ role: 'user', content: 'test' }]
              })
            });
            return response.status !== 401 && response.status !== 403;
          } catch {
            return false;
          }
        }

        async function verifyGoogle(key) {
          try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyHuggingFace(key) {
          try {
            const response = await fetch('https://huggingface.co/api/whoami', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyReplicate(key) {
          try {
            const response = await fetch('https://api.replicate.com/v1/account', {
              headers: { 'Authorization': `Token ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyTogether(key) {
          try {
            const response = await fetch('https://api.together.xyz/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyOpenRouter(key) {
          try {
            const response = await fetch('https://openrouter.ai/api/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyPerplexity(key) {
          try {
            const response = await fetch('https://api.perplexity.ai/chat/completions', {
              method: 'POST',
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: 'llama-3.1-sonar-small-128k-online',
                messages: [{ role: 'user', content: 'test' }],
                max_tokens: 1
              })
            });
            return response.status !== 401 && response.status !== 403;
          } catch {
            return false;
          }
        }

        async function verifyGroq(key) {
          try {
            const response = await fetch('https://api.groq.com/openai/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // ä»ä»£ç ä¸Šä¸‹æ–‡æå–Azure OpenAI endpoint
        function extractAzureEndpoint(context) {
          if (!context) return null;
          
          const endpointPatterns = [
            // ç›´æ¥çš„https URL
            /https:\/\/[\w-]+\.openai\.azure\.com[^\s"'\)\];,}]*/gi,
            // ç¯å¢ƒå˜é‡æ ¼å¼
            /AZURE_OPENAI_ENDPOINT["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            /OPENAI_API_BASE["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]+)/gi,
            // å±æ€§èµ‹å€¼æ ¼å¼
            /endpoint["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]*\.openai\.azure\.com[^"'\s,}\]\)\n]*)/gi,
            /base_url["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]*\.openai\.azure\.com[^"'\s,}\]\)\n]*)/gi,
            /api_base["\s]*[:=]["\s]*["'`]?([^"'\s,}\]\)\n]*\.openai\.azure\.com[^"'\s,}\]\)\n]*)/gi,
            // å­—ç¬¦ä¸²å½¢å¼
            /"[^"]*\.openai\.azure\.com[^"]*"/gi,
            /'[^']*\.openai\.azure\.com[^']*'/gi
          ];
          
          for (const pattern of endpointPatterns) {
            const matches = [...context.matchAll(pattern)];
            if (matches.length > 0) {
              for (const match of matches) {
                let endpoint = match[1] || match[0];
                // æ¸…ç†å¼•å·å’Œç©ºæ ¼
                endpoint = endpoint.replace(/^["'`\s]|["'`\s]$/g, '');
                
                // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„Azure OpenAI endpoint
                if (endpoint.includes('.openai.azure.com') && endpoint.startsWith('https://')) {
                  return endpoint.replace(/\/$/, ''); // ç§»é™¤æœ«å°¾æ–œæ 
                }
              }
            }
          }
          
          return null;
        }

        // éªŒè¯Azure OpenAIå¯†é’¥
        async function verifyAzureOpenAI(key, context) {
          try {
            // æ£€æŸ¥å¯†é’¥æ ¼å¼
            if (!key || key.length < 16) {
              return false;
            }
            
            // å°è¯•ä»ä¸Šä¸‹æ–‡æå–endpoint
            const endpoint = extractAzureEndpoint(context);
            
            if (!endpoint) {
              console.log('Azure OpenAI: No endpoint found in context, skipping verification');
              return false;
            }
            
            console.log(`Azure OpenAI: Trying endpoint ${endpoint}`);
            
            // å°è¯•è°ƒç”¨models API
            const modelsUrl = `${endpoint}/openai/models?api-version=2023-12-01-preview`;
            const response = await fetch(modelsUrl, {
              headers: { 
                'api-key': key,
                'Content-Type': 'application/json'
              }
            });
            
            // Azure OpenAI æˆåŠŸçš„å“åº”ç 
            if (response.ok) {
              console.log('Azure OpenAI: Verification successful');
              return true;
            }
            
            // å¦‚æœæ˜¯401æˆ–403ï¼Œè¯´æ˜å¯†é’¥æ— æ•ˆ
            if (response.status === 401 || response.status === 403) {
              console.log('Azure OpenAI: Invalid key (401/403)');
              return false;
            }
            
            // å…¶ä»–é”™è¯¯å¯èƒ½æ˜¯ç½‘ç»œæˆ–é…ç½®é—®é¢˜
            console.log(`Azure OpenAI: Unexpected response ${response.status}`);
            return false;
            
          } catch (error) {
            console.log('Azure OpenAI: Verification error:', error.message);
            return false;
          }
        }

        // éªŒè¯Google Vertex AIå¯†é’¥
        async function verifyVertexAI(key) {
          try {
            // å°è¯•è°ƒç”¨Google Cloud API
            const response = await fetch('https://us-central1-aiplatform.googleapis.com/v1/projects/*/locations/us-central1/models', {
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // éªŒè¯Cohereå¯†é’¥
        async function verifyCohere(key) {
          try {
            const response = await fetch('https://api.cohere.ai/v1/models', {
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // éªŒè¯Mistralå¯†é’¥
        async function verifyMistral(key) {
          try {
            const response = await fetch('https://api.mistral.ai/v1/models', {
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // è¿è¡ŒéªŒè¯ä»»åŠ¡
        verifyUnverifiedKeys();
        EOF
        
        # è¿è¡ŒéªŒè¯è„šæœ¬
        node verify-task.js
        
        echo "âœ… Key verification task completed"

    - name: Upload verification logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: verification-logs-${{ github.run_number }}
        path: |
          *.log
        retention-days: 7