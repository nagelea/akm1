name: Periodic Key Verification

on:
  schedule:
    # æ¯å¤©æ—©ä¸Š6ç‚¹éªŒè¯æœªéªŒè¯çš„å¯†é’¥
    - cron: '0 6 * * *'
  workflow_dispatch:
    inputs:
      force_reverify:
        description: 'Force re-verify all keys'
        required: false
        default: 'false'
        type: boolean

jobs:
  verify:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm install @supabase/supabase-js
      
    - name: Run Key Verification
      env:
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        FORCE_REVERIFY: ${{ github.event.inputs.force_reverify || 'false' }}
      run: |
        echo "ğŸ” Starting Key Verification Task..."
        echo "Force re-verify: $FORCE_REVERIFY"
        
        # åˆ›å»ºéªŒè¯è„šæœ¬
        cat > verify-task.js << 'EOF'
        const { createClient } = require('@supabase/supabase-js');

        const supabase = createClient(
          process.env.SUPABASE_URL,
          process.env.SUPABASE_SERVICE_KEY
        );

        async function verifyUnverifiedKeys() {
          try {
            console.log('ğŸ” Fetching unverified keys...');
            
            // è·å–æœªéªŒè¯çš„å¯†é’¥ï¼ˆstatus = 'unknown' æˆ– last_verified ä¸ºç©ºï¼‰
            const query = supabase
              .from('leaked_keys')
              .select('id, key_type, leaked_keys_sensitive(*)')
              .eq('status', 'unknown');
            
            if (process.env.FORCE_REVERIFY === 'true') {
              console.log('ğŸ”„ Force re-verification mode - checking all keys');
              // å¼ºåˆ¶é‡æ–°éªŒè¯æ¨¡å¼ï¼šè·å–æ‰€æœ‰å¯†é’¥
              const { data: keys, error } = await supabase
                .from('leaked_keys')
                .select('id, key_type, leaked_keys_sensitive(*)')
                .order('created_at', { ascending: false });
              
              if (error) throw error;
              await processKeys(keys);
            } else {
              // æ­£å¸¸æ¨¡å¼ï¼šåªéªŒè¯æœªéªŒè¯çš„å¯†é’¥
              const { data: keys, error } = await query;
              
              if (error) throw error;
              await processKeys(keys);
            }
            
          } catch (error) {
            console.error('âŒ Verification task failed:', error);
            process.exit(1);
          }
        }

        async function processKeys(keys) {
          if (!keys || keys.length === 0) {
            console.log('âœ… No keys to verify');
            return;
          }

          console.log(`ğŸ“Š Found ${keys.length} keys to verify`);
          let successCount = 0;
          let failureCount = 0;

          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ•æ„Ÿæ•°æ®
            if (!key.leaked_keys_sensitive || 
                key.leaked_keys_sensitive.length === 0 || 
                !key.leaked_keys_sensitive[0].full_key) {
              console.log(`âš ï¸  Skipping key ${key.id} - no sensitive data`);
              continue;
            }

            try {
              console.log(`ğŸ”‘ Verifying key ${i + 1}/${keys.length}: ID ${key.id} (${key.key_type})`);
              
              const sensitiveData = key.leaked_keys_sensitive[0];
              const verificationResult = await verifyKey(key.key_type, sensitiveData.full_key);
              
              // æ£€æŸ¥æ˜¯å¦ä¸ºä¸æ”¯æŒçš„å¯†é’¥ç±»å‹
              if (verificationResult === 'unsupported') {
                console.log(`âš ï¸  Key ${key.id} (${key.key_type}) - verification not supported, keeping as unknown`);
                continue; // è·³è¿‡æ›´æ–°ï¼Œä¿æŒ unknown çŠ¶æ€
              }
              
              // æ›´æ–°æ•°æ®åº“çŠ¶æ€
              const { error: updateError } = await supabase
                .from('leaked_keys')
                .update({
                  status: verificationResult ? 'valid' : 'invalid',
                  last_verified: new Date().toISOString()
                })
                .eq('id', key.id);

              if (updateError) {
                console.error(`âŒ Failed to update key ${key.id}:`, updateError);
                failureCount++;
              } else {
                console.log(`âœ… Key ${key.id} verified as ${verificationResult ? 'valid' : 'invalid'}`);
                successCount++;
              }

              // æ·»åŠ å»¶è¿Ÿé¿å…APIé€Ÿç‡é™åˆ¶
              if (i < keys.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2ç§’å»¶è¿Ÿ
              }

            } catch (error) {
              console.error(`âŒ Error verifying key ${key.id}:`, error);
              failureCount++;
            }
          }

          console.log(`ğŸ¯ Verification completed: ${successCount} success, ${failureCount} failures`);
        }

        async function verifyKey(keyType, fullKey) {
          try {
            switch (keyType.toLowerCase()) {
              case 'openai':
              case 'openai_org':
              case 'deepseek':
                return await verifyOpenAI(fullKey);
              case 'anthropic':
                return await verifyAnthropic(fullKey);
              case 'google':
              case 'google_service':
              case 'palm':
              case 'gemini':
                return await verifyGoogle(fullKey);
              case 'huggingface':
                return await verifyHuggingFace(fullKey);
              case 'replicate':
                return await verifyReplicate(fullKey);
              case 'together':
                return await verifyTogether(fullKey);
              case 'openrouter':
                return await verifyOpenRouter(fullKey);
              case 'perplexity':
                return await verifyPerplexity(fullKey);
              case 'groq':
                return await verifyGroq(fullKey);
              case 'azure_openai':
                // Azure OpenAI éœ€è¦endpointï¼Œæš‚æ—¶è¿”å›false
                return await verifyAzureOpenAI(fullKey, null);
              case 'vertex_ai':
                return await verifyVertexAI(fullKey);
              case 'cohere':
                return await verifyCohere(fullKey);
              case 'mistral':
                return await verifyMistral(fullKey);
              default:
                console.log(`âš ï¸  Unsupported key type: ${keyType}`);
                return 'unsupported';
            }
          } catch (error) {
            console.error(`Verification error for ${keyType}:`, error);
            return false;
          }
        }

        async function verifyOpenAI(key) {
          try {
            const response = await fetch('https://api.openai.com/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyAnthropic(key) {
          try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              headers: { 
                'x-api-key': key,
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01'
              },
              body: JSON.stringify({
                model: 'claude-3-haiku-20240307',
                max_tokens: 1,
                messages: [{ role: 'user', content: 'test' }]
              })
            });
            return response.status !== 401 && response.status !== 403;
          } catch {
            return false;
          }
        }

        async function verifyGoogle(key) {
          try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyHuggingFace(key) {
          try {
            const response = await fetch('https://huggingface.co/api/whoami', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyReplicate(key) {
          try {
            const response = await fetch('https://api.replicate.com/v1/account', {
              headers: { 'Authorization': `Token ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyTogether(key) {
          try {
            const response = await fetch('https://api.together.xyz/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyOpenRouter(key) {
          try {
            const response = await fetch('https://openrouter.ai/api/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyPerplexity(key) {
          try {
            const response = await fetch('https://api.perplexity.ai/chat/completions', {
              method: 'POST',
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: 'llama-3.1-sonar-small-128k-online',
                messages: [{ role: 'user', content: 'test' }],
                max_tokens: 1
              })
            });
            return response.status !== 401 && response.status !== 403;
          } catch {
            return false;
          }
        }

        async function verifyGroq(key) {
          try {
            const response = await fetch('https://api.groq.com/openai/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // éªŒè¯Azure OpenAIå¯†é’¥
        async function verifyAzureOpenAI(key, endpoint) {
          try {
            // Azure OpenAI éœ€è¦ endpoint å’Œ api-key
            // å¦‚æœæ²¡æœ‰endpointï¼Œè¿”å›false
            if (!endpoint) {
              return false;
            }
            
            const response = await fetch(`${endpoint}/openai/models?api-version=2023-12-01-preview`, {
              headers: { 
                'api-key': key,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // éªŒè¯Google Vertex AIå¯†é’¥
        async function verifyVertexAI(key) {
          try {
            // å°è¯•è°ƒç”¨Google Cloud API
            const response = await fetch('https://us-central1-aiplatform.googleapis.com/v1/projects/*/locations/us-central1/models', {
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // éªŒè¯Cohereå¯†é’¥
        async function verifyCohere(key) {
          try {
            const response = await fetch('https://api.cohere.ai/v1/models', {
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // éªŒè¯Mistralå¯†é’¥
        async function verifyMistral(key) {
          try {
            const response = await fetch('https://api.mistral.ai/v1/models', {
              headers: { 
                'Authorization': `Bearer ${key}`,
                'Content-Type': 'application/json'
              }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // è¿è¡ŒéªŒè¯ä»»åŠ¡
        verifyUnverifiedKeys();
        EOF
        
        # è¿è¡ŒéªŒè¯è„šæœ¬
        node verify-task.js
        
        echo "âœ… Key verification task completed"

    - name: Upload verification logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: verification-logs-${{ github.run_number }}
        path: |
          *.log
        retention-days: 7