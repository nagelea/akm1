name: Periodic Key Verification

on:
  schedule:
    # ÊØèÂ§©Êó©‰∏ä6ÁÇπÈ™åËØÅÊú™È™åËØÅÁöÑÂØÜÈí•
    - cron: '0 6 * * *'
  workflow_dispatch:
    inputs:
      force_reverify:
        description: 'Force re-verify all keys'
        required: false
        default: 'false'
        type: boolean

jobs:
  verify:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm install @supabase/supabase-js
      
    - name: Run Key Verification
      env:
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        FORCE_REVERIFY: ${{ github.event.inputs.force_reverify || 'false' }}
      run: |
        echo "üîç Starting Key Verification Task..."
        echo "Force re-verify: $FORCE_REVERIFY"
        
        # ÂàõÂª∫È™åËØÅËÑöÊú¨
        cat > verify-task.js << 'EOF'
        const { createClient } = require('@supabase/supabase-js');

        const supabase = createClient(
          process.env.SUPABASE_URL,
          process.env.SUPABASE_SERVICE_KEY
        );

        async function verifyUnverifiedKeys() {
          try {
            console.log('üîç Fetching unverified keys...');
            
            // Ëé∑ÂèñÊú™È™åËØÅÁöÑÂØÜÈí•Ôºàstatus = 'unknown' Êàñ last_verified ‰∏∫Á©∫Ôºâ
            const query = supabase
              .from('leaked_keys')
              .select('id, key_type, leaked_keys_sensitive(*)')
              .eq('status', 'unknown');
            
            if (process.env.FORCE_REVERIFY === 'true') {
              console.log('üîÑ Force re-verification mode - checking all keys');
              // Âº∫Âà∂ÈáçÊñ∞È™åËØÅÊ®°ÂºèÔºöËé∑ÂèñÊâÄÊúâÂØÜÈí•
              const { data: keys, error } = await supabase
                .from('leaked_keys')
                .select('id, key_type, leaked_keys_sensitive(*)')
                .order('created_at', { ascending: false });
              
              if (error) throw error;
              await processKeys(keys);
            } else {
              // Ê≠£Â∏∏Ê®°ÂºèÔºöÂè™È™åËØÅÊú™È™åËØÅÁöÑÂØÜÈí•
              const { data: keys, error } = await query;
              
              if (error) throw error;
              await processKeys(keys);
            }
            
          } catch (error) {
            console.error('‚ùå Verification task failed:', error);
            process.exit(1);
          }
        }

        async function processKeys(keys) {
          if (!keys || keys.length === 0) {
            console.log('‚úÖ No keys to verify');
            return;
          }

          console.log(`üìä Found ${keys.length} keys to verify`);
          let successCount = 0;
          let failureCount = 0;

          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊïèÊÑüÊï∞ÊçÆ
            if (!key.leaked_keys_sensitive || 
                key.leaked_keys_sensitive.length === 0 || 
                !key.leaked_keys_sensitive[0].full_key) {
              console.log(`‚ö†Ô∏è  Skipping key ${key.id} - no sensitive data`);
              continue;
            }

            try {
              console.log(`üîë Verifying key ${i + 1}/${keys.length}: ID ${key.id} (${key.key_type})`);
              
              const sensitiveData = key.leaked_keys_sensitive[0];
              const isValid = await verifyKey(key.key_type, sensitiveData.full_key);
              
              // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
              const { error: updateError } = await supabase
                .from('leaked_keys')
                .update({
                  status: isValid ? 'valid' : 'invalid',
                  last_verified: new Date().toISOString()
                })
                .eq('id', key.id);

              if (updateError) {
                console.error(`‚ùå Failed to update key ${key.id}:`, updateError);
                failureCount++;
              } else {
                console.log(`‚úÖ Key ${key.id} verified as ${isValid ? 'valid' : 'invalid'}`);
                successCount++;
              }

              // Ê∑ªÂä†Âª∂ËøüÈÅøÂÖçAPIÈÄüÁéáÈôêÂà∂
              if (i < keys.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2ÁßíÂª∂Ëøü
              }

            } catch (error) {
              console.error(`‚ùå Error verifying key ${key.id}:`, error);
              failureCount++;
            }
          }

          console.log(`üéØ Verification completed: ${successCount} success, ${failureCount} failures`);
        }

        async function verifyKey(keyType, fullKey) {
          try {
            switch (keyType.toLowerCase()) {
              case 'openai':
              case 'openai_org':
              case 'deepseek':
                return await verifyOpenAI(fullKey);
              case 'anthropic':
                return await verifyAnthropic(fullKey);
              case 'google':
              case 'google_service':
              case 'palm':
              case 'gemini':
                return await verifyGoogle(fullKey);
              case 'huggingface':
                return await verifyHuggingFace(fullKey);
              case 'replicate':
                return await verifyReplicate(fullKey);
              default:
                console.log(`‚ö†Ô∏è  Unsupported key type: ${keyType}`);
                return false;
            }
          } catch (error) {
            console.error(`Verification error for ${keyType}:`, error);
            return false;
          }
        }

        async function verifyOpenAI(key) {
          try {
            const response = await fetch('https://api.openai.com/v1/models', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyAnthropic(key) {
          try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              headers: { 
                'x-api-key': key,
                'Content-Type': 'application/json',
                'anthropic-version': '2023-06-01'
              },
              body: JSON.stringify({
                model: 'claude-3-haiku-20240307',
                max_tokens: 1,
                messages: [{ role: 'user', content: 'test' }]
              })
            });
            return response.status !== 401 && response.status !== 403;
          } catch {
            return false;
          }
        }

        async function verifyGoogle(key) {
          try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyHuggingFace(key) {
          try {
            const response = await fetch('https://huggingface.co/api/whoami', {
              headers: { 'Authorization': `Bearer ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        async function verifyReplicate(key) {
          try {
            const response = await fetch('https://api.replicate.com/v1/account', {
              headers: { 'Authorization': `Token ${key}` }
            });
            return response.ok;
          } catch {
            return false;
          }
        }

        // ËøêË°åÈ™åËØÅ‰ªªÂä°
        verifyUnverifiedKeys();
        EOF
        
        # ËøêË°åÈ™åËØÅËÑöÊú¨
        node verify-task.js
        
        echo "‚úÖ Key verification task completed"

    - name: Upload verification logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: verification-logs-${{ github.run_number }}
        path: |
          *.log
        retention-days: 7