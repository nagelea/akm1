name: Scan Status Monitor

on:
  schedule:
    # æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡æ‰«æçŠ¶æ€
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      report_type:
        description: 'Type of report to generate'
        required: false
        default: 'summary'
        type: choice
        options:
          - summary
          - detailed
          - performance

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Generate scan status report
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          REPORT_TYPE: ${{ github.event.inputs.report_type || 'summary' }}
        run: |
          # åˆ›å»ºçŠ¶æ€ç›‘æ§è„šæœ¬
          cat > scan_monitor.js << 'EOF'
          const { createClient } = require('@supabase/supabase-js');
          
          async function generateReport() {
            const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_KEY);
            const reportType = process.env.REPORT_TYPE || 'summary';
            
            try {
              console.log('ğŸ“Š MULTI-SOURCE SCAN STATUS REPORT');
              console.log('=' .repeat(50));
              console.log(`Report Type: ${reportType.toUpperCase()}`);
              console.log(`Generated: ${new Date().toISOString()}`);
              console.log('=' .repeat(50));
              
              // è·å–æœ€è¿‘24å°æ—¶çš„å‘ç°
              const { data: recentKeys, error: keysError } = await supabase
                .from('leaked_keys')
                .select('service, source_type, severity, confidence, created_at')
                .gte('created_at', new Date(Date.now() - 24*60*60*1000).toISOString())
                .order('created_at', { ascending: false });
              
              if (keysError) throw keysError;
              
              console.log(`\nğŸ”‘ RECENT DISCOVERIES (Last 24h): ${recentKeys.length} keys`);
              
              if (recentKeys.length > 0) {
                // æŒ‰æ•°æ®æºåˆ†ç»„
                const bySource = recentKeys.reduce((acc, key) => {
                  const source = key.source_type || 'unknown';
                  acc[source] = (acc[source] || 0) + 1;
                  return acc;
                }, {});
                
                console.log('\nğŸ“‹ By Data Source:');
                for (const [source, count] of Object.entries(bySource)) {
                  const emoji = source.includes('github') ? 'ğŸ™' : 
                               source.includes('gitlab') ? 'ğŸ¦Š' : 
                               source.includes('gist') ? 'ğŸ“' : 'ğŸ”';
                  console.log(`   ${emoji} ${source}: ${count} keys`);
                }
                
                // æŒ‰æœåŠ¡åˆ†ç»„
                const byService = recentKeys.reduce((acc, key) => {
                  acc[key.service] = (acc[key.service] || 0) + 1;
                  return acc;
                }, {});
                
                console.log('\nğŸ¤– By AI Service:');
                for (const [service, count] of Object.entries(byService)) {
                  console.log(`   ${service}: ${count} keys`);
                }
                
                // ä¸¥é‡ç¨‹åº¦åˆ†å¸ƒ
                const bySeverity = recentKeys.reduce((acc, key) => {
                  acc[key.severity] = (acc[key.severity] || 0) + 1;
                  return acc;
                }, {});
                
                console.log('\nâš ï¸  By Severity:');
                for (const [severity, count] of Object.entries(bySeverity)) {
                  const emoji = severity === 'high' ? 'ğŸ”´' : 
                               severity === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢';
                  console.log(`   ${emoji} ${severity}: ${count} keys`);
                }
              }
              
              // è·å–æ‰«æä¼šè¯ç»Ÿè®¡
              if (reportType === 'detailed' || reportType === 'performance') {
                const { data: sessions, error: sessionsError } = await supabase
                  .from('scan_sessions')
                  .select('*')
                  .gte('completed_at', new Date(Date.now() - 7*24*60*60*1000).toISOString())
                  .order('completed_at', { ascending: false })
                  .limit(10);
                
                if (!sessionsError && sessions.length > 0) {
                  console.log(`\nğŸ”„ RECENT SCAN SESSIONS (Last 7 days): ${sessions.length}`);
                  
                  sessions.forEach((session, index) => {
                    const duration = (session.duration_ms / 1000 / 60).toFixed(1);
                    const status = session.status === 'completed' ? 'âœ…' : 
                                  session.status === 'failed' ? 'âŒ' : 'ğŸ”„';
                    console.log(`   ${status} ${session.scan_type} (${session.sources?.join(',') || 'N/A'}) - ${session.total_found} keys in ${duration}m`);
                  });
                }
              }
              
              // æ€§èƒ½ç»Ÿè®¡
              if (reportType === 'performance') {
                const { data: sourceStats, error: statsError } = await supabase
                  .from('data_source_stats')
                  .select('*')
                  .gte('scan_date', new Date(Date.now() - 7*24*60*60*1000).toISOString().split('T')[0]);
                
                if (!statsError && sourceStats.length > 0) {
                  console.log('\nâš¡ PERFORMANCE METRICS (Last 7 days):');
                  
                  const perfBySource = sourceStats.reduce((acc, stat) => {
                    if (!acc[stat.source_name]) {
                      acc[stat.source_name] = {
                        requests: 0,
                        keys: 0,
                        avgResponse: 0,
                        errors: 0
                      };
                    }
                    acc[stat.source_name].requests += stat.requests_made || 0;
                    acc[stat.source_name].keys += stat.keys_extracted || 0;
                    acc[stat.source_name].avgResponse += stat.avg_response_time_ms || 0;
                    acc[stat.source_name].errors += stat.errors_count || 0;
                    return acc;
                  }, {});
                  
                  for (const [source, stats] of Object.entries(perfBySource)) {
                    console.log(`   ğŸ“Š ${source}:`);
                    console.log(`      Requests: ${stats.requests}, Keys: ${stats.keys}, Errors: ${stats.errors}`);
                    console.log(`      Avg Response: ${(stats.avgResponse / sourceStats.filter(s => s.source_name === source).length).toFixed(0)}ms`);
                  }
                }
              }
              
              // æ€»ä½“ç»Ÿè®¡
              const { data: totalStats, error: totalError } = await supabase
                .from('leaked_keys')
                .select('service, created_at')
                .gte('created_at', new Date(Date.now() - 30*24*60*60*1000).toISOString());
              
              if (!totalError) {
                console.log(`\nğŸ“ˆ TOTAL STATISTICS (Last 30 days):`);
                console.log(`   ğŸ”‘ Total Keys Found: ${totalStats.length}`);
                console.log(`   ğŸ“… Daily Average: ${(totalStats.length / 30).toFixed(1)} keys/day`);
                
                const uniqueServices = new Set(totalStats.map(k => k.service)).size;
                console.log(`   ğŸ¤– Services Monitored: ${uniqueServices}`);
              }
              
              console.log('\n' + '=' .repeat(50));
              console.log('ğŸ¯ Next scheduled scans:');
              console.log('   GitHub: Every 4 hours');
              console.log('   GitLab: Daily at 14:00 UTC'); 
              console.log('   Multi-source: Daily at 08:00 & 20:00 UTC');
              console.log('=' .repeat(50));
              
            } catch (error) {
              console.error('âŒ Report generation failed:', error.message);
              process.exit(1);
            }
          }
          
          generateReport();
          EOF
          
          node scan_monitor.js
          
      - name: Check for critical alerts
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # æ£€æŸ¥æ˜¯å¦æœ‰é«˜å±å¯†é’¥éœ€è¦ç«‹å³å…³æ³¨
          cat > alert_check.js << 'EOF'
          const { createClient } = require('@supabase/supabase-js');
          
          async function checkAlerts() {
            const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_KEY);
            
            try {
              // æ£€æŸ¥æœ€è¿‘1å°æ—¶çš„é«˜å±å‘ç°
              const { data: criticalKeys, error } = await supabase
                .from('leaked_keys')
                .select('service, key_partial, source_url, created_at')
                .eq('severity', 'high')
                .gte('created_at', new Date(Date.now() - 60*60*1000).toISOString());
              
              if (error) throw error;
              
              if (criticalKeys.length > 0) {
                console.log('ğŸš¨ CRITICAL ALERT: High severity keys found!');
                console.log(`   Count: ${criticalKeys.length}`);
                console.log('   Services affected:', [...new Set(criticalKeys.map(k => k.service))].join(', '));
                console.log('   Immediate action recommended!');
                
                // åœ¨å®é™…ç¯å¢ƒä¸­ï¼Œè¿™é‡Œå¯ä»¥å‘é€é€šçŸ¥åˆ°Slack/Discord/Email
                process.exit(1); // ä½¿workflowæ˜¾ç¤ºä¸ºå¤±è´¥çŠ¶æ€ä»¥å¼•èµ·æ³¨æ„
              } else {
                console.log('âœ… No critical alerts in the last hour');
              }
              
            } catch (error) {
              console.error('Alert check failed:', error.message);
            }
          }
          
          checkAlerts();
          EOF
          
          node alert_check.js
          
      - name: Update monitoring badge
        if: always()
        run: |
          # åˆ›å»ºçŠ¶æ€å¾½ç« ä¿¡æ¯
          STATUS="active"
          if [ $? -ne 0 ]; then
            STATUS="alert"
          fi
          
          echo "ğŸ“Š Monitoring Status: $STATUS"
          echo "Last Check: $(date -u)"